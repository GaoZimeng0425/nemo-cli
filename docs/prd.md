---
stepsCompleted: [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]
inputDocuments:
  - docs/index.md
  - docs/architecture.md
  - docs/packages-git/command-reference.md
  - docs/packages-git/architecture.md
  - docs/development-guide.md
documentCounts:
  briefs: 0
  research: 0
  brainstorming: 0
  projectDocs: 5
workflowType: 'prd'
lastStep: 0
project_name: 'nemo-cli'
user_name: 'BMad'
date: '2025-12-21'
---

# nemo-cli - 产品需求文档

**Author:** BMad
**Date:** 2025-12-21
**Version:** 1.0

---

## Executive Summary

nemo-cli 是一个面向软件工程师的 CLI 工具集，旨在通过**智能推断和自动编排**，消除命令行操作的认知负担。核心原则是：**开发者只需表达意图，工具自动处理执行细节。**

传统 CLI 工具要求开发者：

- 记忆命令语法和参数顺序
- 理解底层工具的实现细节
- 手动编排多步骤操作序列
- 在不同工具间切换上下文

nemo-cli 从根本上重新思考 CLI 交互：

- **意图优先**：开发者说"提交代码"，工具自动处理暂存、格式化、提交信息生成
- **上下文感知**：工具自动检测当前状态（分支、未提交文件、依赖冲突），无需用户告知
- **自动编排**：复杂操作序列（stash → pull → pop）自动执行，开发者无需记忆步骤
- **一致性体验**：所有命令（ng, na, np, nf）遵循相同的交互模式，降低学习成本

**用户旅程优化：**

nemo-cli 针对开发者完整使用旅程的每个阶段进行优化：

- **发现阶段**：清晰的 README、快速上手示例、直观的命令命名（ng, na, np, nf）
- **学习阶段**：统一的交互模式（学会一个，理解全部）、智能提示、上下文相关的帮助
- **日常使用阶段**：零记忆负担的命令设计、自动推断用户意图、静默处理琐碎操作
- **进阶使用阶段**：丰富的配置选项、跨模块协同能力、可扩展的架构
- **问题解决阶段**：清晰的错误信息、自动恢复建议、详细的帮助文档

**旅程中的关键改进：**

- **消除学习曲线痛点**：通过统一交互模式，将学习成本从"每个命令都要学"降低到"学会模式即可"
- **减少上下文切换负担**：所有命令遵循相同设计，无需在不同工具间切换思维模式
- **提升错误处理体验**：智能错误诊断、自动恢复建议、清晰的解决路径

**价值链架构：**

nemo-cli 通过 Monorepo 架构构建了高效的价值创造体系：

- **主要活动层**：Git、File、Package、AI 等核心功能模块，直接为开发者创造价值
- **支持活动层**：@nemo-cli/shared（统一基础能力）、@nemo-cli/ui（一致交互体验）作为共享基础设施
- **价值连接**：所有模块共享相同的基础能力和交互模式，形成"学会一个，理解全部"的协同效应
- **价值优化**：通过共享核心减少重复开发，通过统一体验降低学习成本，通过智能推断提升效率

nemo-cli 采用 Monorepo 架构，提供多个独立但统一的 CLI 命令：

- **ng** (git) - Git 操作辅助，已实现智能提交、安全分支切换
- **na** (ai) - AI CLI + MCP 服务器，集成 Confluence、邮件、Slack
- **np** (package) - pnpm 工作区管理
- **nf** (file) - 文件 AST 操作

本次 PRD 定义整体工具集的愿景和路线图，所有功能模块将继续深化智能化，优先级为：**Git > AI > Package > File**。

### What Makes This Special

**"让命令行操作像思考一样自然"**

传统 CLI 工具将认知负担转嫁给开发者：需要学习工具，而非使用工具。开发者必须成为"工具专家"才能完成简单任务。

nemo-cli 的差异化价值：

1. **零记忆负担**：命令设计符合直觉，无需查阅文档或记忆参数格式
2. **智能推断**：工具自动检测上下文并推断用户意图，减少交互步骤
3. **自动编排**：复杂操作序列自动执行，开发者只需表达最终目标
4. **一致性体验**：所有命令遵循统一的设计模式，学会一个，理解全部
5. **价值链协同**：通过共享核心和统一体验，形成"1+1>2"的协同效应，降低整体学习成本
6. **旅程优化**：针对开发者完整使用旅程的每个阶段进行优化，从发现到精通，全程降低摩擦

**核心洞察：** CLI 工具不应要求开发者成为工具专家，而应让开发者专注于业务逻辑。nemo-cli 通过智能推断和自动编排，将"使用工具"转变为"表达意图"。同时，通过 Monorepo 架构和共享核心，实现了价值创造的最大化和学习成本的最小化。更重要的是，nemo-cli 关注开发者完整使用旅程的每个阶段，确保从首次使用到深度掌握，每一步都尽可能顺畅自然。

---

## Project Classification

**Technical Type:** CLI 工具 (cli_tool)
**Domain:** 开发者工具 (Developer Tools)
**Complexity:** 低（通用软件开发，无特殊合规要求）
**Project Context:** 棕地项目 - 扩展现有系统

本项目在现有的 nemo-cli Monorepo 基础上，定义整体工具集的愿景和智能化深化路线图。项目采用 TypeScript + Monorepo 架构，使用 Commander.js 作为 CLI 框架，@clack/prompts 提供交互式提示，React Ink 构建终端 UI。

**现有能力（已实现）：**

- `ng commit` - 交互式智能提交流程
- `ng checkout` - 安全分支切换（带 stash）
- `ng pull` / `ng push` - 基础拉取/推送
- `ng branch clean` - 清理已合并分支
- `ng stash` - Stash 管理
- `ng merge` - 分支合并
- `na` - AI CLI + MCP 服务器
- `np list` / `np upgrade` - 包管理基础功能
- `nf ast` - 文件 AST 分析

**本次 PRD 目标：**

- 定义整体工具集愿景和智能化方向
- 规划各模块深化路线图（Git > AI > Package > File）
- 统一"智能推断 + 自动编排"的设计理念
- 建立简便易用的优先级标准

---

## Success Criteria

### User Success

**零文档依赖（可观测指标）：**

- 90% 以上的日常操作无需查阅文档即可完成
- `--help` 使用率 < 10%（说明帮助足够直观，用户无需频繁查阅）
- `--help` 提供清晰的操作提醒，覆盖 95% 的使用场景
- 首次使用后，用户能在 5 分钟内完成第一个任务
- 首次使用到首次成功操作的时间 < 5 分钟

**流畅使用体验（对比数据）：**

- 命令执行成功率 > 95%（无需回退到原始命令）
- 操作步骤数减少：平均从 3.5 步降至 1.2 步（相比原生命令）
- 用户从"想做什么"到"完成操作"的平均时间减少 50% 以上
- 80% 以上用户认为"比原生命令更方便"
- 用户满意度：NPS (Net Promoter Score) > 50

**用户留存：**

- 30 天留存率 > 70%（用户持续使用工具）
- 用户报告的错误 < 5%（基于总操作数）

**目标用户：** 软件工程师日常开发使用，尤其是前端工程师

### Business Success

**团队内部采用（时间维度里程碑）：**

- **1 个月目标：** 50% 团队成员使用 nemo-cli 作为主要开发工具
- **3 个月目标：** 80% 团队成员使用，每日活跃使用率 > 80%
- **6 个月目标：** 100% 团队成员使用，工具成为团队标准工作流的一部分

**衡量指标：**

- 每日活跃使用率：团队成员每天至少使用一次的比例
- 工具成为团队标准工作流：在团队文档、流程中正式采用

### Technical Success

**可维护性（具体量化指标）：**

- **代码质量：** 遵循 TypeScript 最佳实践，通过所有 lint 检查
- **代码覆盖率：** 单元测试覆盖率 > 80%
- **代码复杂度：** 新功能代码的圈复杂度 < 10
- **文档覆盖率：** API 文档覆盖率 100%
- **可扩展性：** 新功能添加时间 < 2 天（基于现有架构，需明确"新功能"定义和复杂度）
- **鲁棒性：** 错误处理覆盖率 100%，关键路径异常场景有明确处理

**性能与可靠性（场景化指标）：**

- **Git 操作性能：** 分支切换 < 500ms（包含 stash 操作）
- **AI 操作性能：** 命令响应 < 2s（包含网络延迟）
- **Package 操作性能：** 依赖分析 < 1s
- **通用性能：** 冷启动 < 200ms，热启动 < 100ms
- **操作成功率：** > 99%（排除用户输入错误）
- **错误恢复率：** 自动恢复 > 90%
- **数据完整性：** 零数据丢失（100%）
- **向后兼容：** 现有命令 100% 兼容

**可观测性：**

- **操作日志覆盖率：** 100%（所有操作都有日志记录）
- **错误追踪：** 所有错误可追溯，便于问题排查

### Failure Criteria

**失败标准定义（及时调整的预警指标）：**

- 如果 3 个月内团队采用率 < 50%，需要重新评估推广策略
- 如果用户留存率 < 50%，需要重新审视用户体验
- 如果错误率 > 10%，需要优先修复稳定性问题
- 如果新功能添加时间 > 5 天，需要优化架构和开发流程

### Measurable Outcomes

**连接产品差异化价值：**
这些成功标准与"让命令行操作像思考一样自然"的核心价值一致：

- 零文档依赖 → 智能推断和一致性体验
- 团队内部采用 → 价值链协同和统一体验
- 可维护性 → 支持长期演进和功能扩展

---

## Product Scope

### MVP - Minimum Viable Product

**核心功能（必须实现才能证明概念）：**

1. **Git 模块智能化深化**
   - 分支级别 Stash 管理（切换分支时自动 stash，切换回时自动 pop）
   - Pull 安全模式（自动检测未提交更改，自动 stash → pull → pop）
   - Push 安全模式（push 前自动 pull，避免推送过时代码）
   - Rebase 工作流优化（智能检测是否需要 force push）

2. **统一的帮助系统**
   - 所有命令支持 `--help`，提供上下文相关的操作提醒
   - 帮助信息清晰、简洁，覆盖 95% 的使用场景
   - 智能提示：根据当前上下文提供相关命令建议

3. **基础错误处理和恢复**
   - 关键路径异常场景有明确处理
   - 清晰的错误信息，提供恢复建议
   - 操作日志记录，便于问题排查

### Growth Features (Post-MVP)

**让产品具有竞争力：**

1. **AI 模块智能化深化**
   - 智能推断用户意图，减少交互步骤
   - 上下文感知的 AI 操作建议
   - 跨模块协同（Git + AI 集成）

2. **Package 和 File 模块智能化**
   - Package 模块：智能依赖分析、冲突检测、升级建议
   - File 模块：智能文件操作、AST 分析增强
   - 统一的交互模式，与 Git 模块保持一致

3. **跨模块协同能力**
   - Git + Package：提交时自动检测依赖变更
   - Git + File：文件操作与版本控制协同
   - AI + 各模块：智能操作建议和自动化

### Vision (Future)

**梦想版本：**

1. **完整的工具集智能化覆盖**
   - 所有模块达到统一的智能化水平
   - 跨模块工作流自动化
   - 智能学习用户习惯，个性化体验

2. **社区生态和插件系统**
   - 插件系统，支持第三方扩展
   - 社区贡献的工作流模板
   - 跨团队配置共享

3. **跨团队协作能力**
   - 团队配置管理
   - 工作流标准化
   - 协作数据分析

---

## Project Scoping & Phased Development

### MVP Strategy & Philosophy

**MVP 方法：** 问题解决型 MVP

nemo-cli 的 MVP 采用问题解决型方法，专注于解决软件工程师在日常 Git 操作中的核心痛点：

- **核心问题**：开发者需要记忆复杂的 Git 命令序列，容易因操作错误导致数据丢失
- **MVP 解决方案**：通过智能推断和自动编排，让开发者只需表达意图，工具自动处理执行细节
- **验证目标**：证明"意图优先"的方法确实比传统方法更高效、更安全

**资源需求：**

- **团队规模**：中小型团队（2-4 人）
- **核心技能**：TypeScript、Git 操作、CLI 开发、交互设计
- **开发周期**：MVP 预计 2-3 个月

### MVP Feature Set (Phase 1)

**核心用户旅程支持：**

- ✅ Journey 1: 前端工程师的日常救赎（主要成功路径）
- ✅ Journey 2: 新团队成员的快速上手（新用户旅程）
- ✅ Journey 3: 处理复杂场景（边缘情况）

**必须实现的能力（Git 操作优先级最高）：**

1. **Git 模块智能化深化（核心）**
   - 分支级别 Stash 管理：自动 stash/pop，分支上下文记忆
   - Pull 安全模式：自动检测并保护未提交更改
   - Push 安全模式：自动 pull 预检查，避免推送过时代码
   - Rebase 工作流优化：智能检测历史重写，安全处理 force push

2. **统一的帮助系统（支持零文档依赖）**
   - 所有命令支持 `--help`，提供上下文相关的操作提醒
   - 帮助信息清晰、简洁，覆盖 95% 的使用场景
   - 智能提示：根据当前上下文提供相关命令建议

3. **基础错误处理和恢复（保证可靠性）**
   - 关键路径异常场景有明确处理
   - 清晰的错误信息，提供恢复建议
   - 操作日志记录，便于问题排查

**MVP 成功标准：**

- 开发者日常 Git 操作中 90% 以上场景可以通过 `ng` 命令完成
- 用户无需查阅文档即可完成 90% 的日常操作
- 命令执行成功率 > 95%
- 零数据丢失（100% 数据完整性）

### Post-MVP Features

**Phase 2 (Growth - 让产品具有竞争力)：**

**优先级：Git > AI > Package > File**

1. **AI 模块智能化深化**
   - 智能推断用户意图，减少交互步骤
   - 上下文感知的 AI 操作建议
   - 跨模块协同（Git + AI 集成）

2. **Package 模块智能化**
   - 智能依赖分析、冲突检测、升级建议
   - 统一的交互模式，与 Git 模块保持一致

3. **File 模块智能化**
   - 智能文件操作、AST 分析增强
   - 统一的交互模式

4. **跨模块协同能力**
   - Git + Package：提交时自动检测依赖变更
   - Git + File：文件操作与版本控制协同
   - AI + 各模块：智能操作建议和自动化

**Phase 3 (Expansion - 梦想版本)：**

1. **完整的工具集智能化覆盖**
   - 所有模块达到统一的智能化水平
   - 跨模块工作流自动化
   - 智能学习用户习惯，个性化体验

2. **社区生态和插件系统**
   - 插件系统，支持第三方扩展
   - 社区贡献的工作流模板
   - 跨团队配置共享

3. **跨团队协作能力**
   - 团队配置管理
   - 工作流标准化
   - 协作数据分析

### Risk Mitigation Strategy

**技术风险：**

**风险 1：智能推断的准确性**

- **风险描述**：工具推断用户意图可能出错，导致执行错误的操作
- **缓解策略**：
  - 关键操作前提供确认提示
  - 提供操作预览，让用户确认后再执行
  - 支持操作撤销和恢复机制
  - 建立操作日志，便于问题排查和回滚

**风险 2：自动操作的可靠性**

- **风险描述**：自动 stash/pull/pop 序列可能失败，导致数据丢失
- **缓解策略**：
  - 所有自动操作必须保证原子性
  - 操作失败时自动回滚到操作前状态
  - 关键操作前创建恢复点
  - 100% 错误处理覆盖率

**风险 3：性能影响**

- **风险描述**：智能推断和自动编排可能增加命令执行时间
- **缓解策略**：
  - 性能目标：分支切换 < 500ms，命令启动 < 200ms
  - 优化上下文检测算法，减少不必要的检查
  - 缓存常用操作结果
  - 性能监控和优化

**市场风险：**

**风险 1：用户采用率低**

- **风险描述**：用户可能不愿意改变现有工作流
- **缓解策略**：
  - 提供平滑的迁移路径（与原生 Git 100% 兼容）
  - 强调核心价值（零数据丢失、无需记忆命令）
  - 团队内部推广，建立使用习惯
  - 1 个月目标：50% 团队采用率

**风险 2：学习曲线**

- **风险描述**：新用户可能需要时间适应新的交互模式
- **缓解策略**：
  - 统一的交互模式（学会一个，理解全部）
  - 清晰的 `--help` 系统，覆盖 95% 使用场景
  - 首次使用 5 分钟内完成第一个任务
  - 提供快速上手指南

**资源风险：**

**风险 1：开发资源不足**

- **风险描述**：如果团队规模小于预期，可能无法按时交付 MVP
- **缓解策略**：
  - MVP 聚焦核心功能（Git 模块智能化）
  - 优先实现高价值功能（分支级 stash、安全 pull/push）
  - 最小可行团队：2 人（1 后端 + 1 前端/交互）
  - 如果资源不足，可以延后非核心功能（AI、Package、File 模块）

**风险 2：技术债务积累**

- **风险描述**：快速迭代可能导致代码质量下降
- **缓解策略**：
  - 代码质量要求：通过所有 lint 检查
  - 单元测试覆盖率 > 80%
  - 代码复杂度 < 10（圈复杂度）
  - 定期重构和技术债务清理

---

## User Journeys

### Journey 1: 张小雨 - 前端工程师的日常救赎

张小雨是一名前端工程师，每天需要频繁切换分支、提交代码、处理依赖。她经常因为忘记 stash 而丢失工作，或者因为 rebase 后的远程冲突而困惑。她希望专注于代码逻辑，而不是记忆 Git 命令。

**开场场景：**
周五下午，小雨正在修复一个紧急 bug。她修改了几个文件，但还没提交。这时需要切换到主分支查看另一个问题。她习惯性地执行 `git checkout main`，结果 Git 提示有未提交的更改。她需要先 stash，但记不清完整的命令序列，只好查文档。

**上升行动：**
同事推荐了 nemo-cli。小雨安装了 `ng`，第一次使用时运行 `ng checkout main`。工具自动检测到未提交的更改，提示是否自动 stash。她选择"是"，工具自动执行 stash → checkout → 显示 stash 列表。切换回原分支时，工具自动识别并 pop 对应的 stash。

**高潮：**
一周后，小雨习惯了使用 `ng`。一次需要 pull 最新代码，她直接运行 `ng pull`。工具自动检测未提交更改，执行 stash → pull → pop。pull 完成后自动 pop，没有冲突。整个过程无需记忆命令，只需表达意图。

**解决：**
一个月后，小雨的日常 Git 操作 90% 以上都通过 `ng` 完成，不再需要查阅文档。她不再因为忘记 stash 而丢失工作，也不再因为 rebase 后的远程冲突而困惑。她可以专注于代码逻辑，而不是 Git 命令序列。

---

### Journey 2: 李明 - 新团队成员的快速上手

李明刚加入团队，需要快速熟悉代码库和团队工作流。团队使用 nemo-cli 作为标准工具，但李明之前没用过。

**开场场景：**
入职第一天，技术负责人告诉李明团队使用 `ng` 进行 Git 操作。李明担心学习成本，但负责人说"很简单，试试 `ng --help`"。

**上升行动：**
李明运行 `ng --help`，看到清晰的命令列表和说明。他尝试 `ng commit`，工具通过交互式提示引导他完成提交：选择文件、提交类型、输入信息。整个过程直观，无需记忆参数格式。

**高潮：**
第三天，李明需要切换分支。他运行 `ng checkout`，工具显示可用分支列表，他选择目标分支。工具自动处理了未提交更改（自动 stash），切换后自动恢复。李明意识到工具已经处理了所有细节。

**解决：**
一周后，李明已经完全适应了团队的工作流。他不再需要记忆 Git 命令，工具的统一交互模式让他快速上手。他专注于理解代码逻辑，而不是工具使用。

---

### Journey 3: 王强 - 处理复杂场景

王强是一名资深全栈工程师，经常处理复杂的 Git 场景，如 rebase、merge 冲突等。

**开场场景：**
王强需要将 feature 分支 rebase 到最新的 main。他知道这可能导致冲突，需要处理。

**上升行动：**
王强运行 `ng rebase main`。工具检测到需要 rebase，提示确认。确认后，工具自动执行 rebase。过程中出现冲突，工具清晰地显示冲突文件列表和解决建议。

**高潮：**
Rebase 完成后，工具检测到历史重写，提示需要 force push。工具提供选项：force push / 查看差异 / 取消。王强选择查看差异，确认无误后选择 force push。工具执行 `git push --force-with-lease`，确保安全。

**解决：**
王强发现即使处理复杂场景，nemo-cli 也能提供清晰的引导和安全的操作。工具不会自动执行危险操作，但会智能提示和引导。

---

### Journey 4: 陈静 - 团队技术负责人的标准化之路

陈静是团队技术负责人，希望统一团队的工具使用，提高协作效率。

**开场场景：**
团队中有成员因为 Git 操作不当导致代码丢失，陈静决定引入标准化工具。她选择了 nemo-cli，因为它提供了统一的交互模式和智能化的操作。

**上升行动：**
陈静在团队文档中说明使用 nemo-cli 作为标准工具，并提供了快速上手指南。她配置了团队级别的默认设置（如 pull 策略、stash 消息格式），确保团队使用一致的工作流。

**高潮：**
一个月后，团队 80% 的成员都在使用 nemo-cli。陈静发现团队协作效率提升：减少了因 Git 操作错误导致的代码丢失，新成员上手更快，代码提交质量更一致。

**解决：**
三个月后，nemo-cli 成为团队标准工作流的一部分。所有成员都使用统一的工具，减少了上下文切换和学习成本。团队可以专注于代码质量，而不是工具使用。

---

### Journey Requirements Summary

这些旅程揭示了以下能力需求：

**1. 智能推断和自动编排**

- 自动检测上下文（未提交更改、分支状态、依赖冲突）
- 自动执行操作序列（stash → checkout → pop，stash → pull → pop）
- 智能推断用户意图，减少交互步骤

**2. 统一的交互模式**

- 所有命令（ng, na, np, nf）遵循相同的交互范式
- 清晰的 `--help` 系统，提供上下文相关的操作提醒
- 交互式引导，无需记忆参数格式

**3. 错误处理和恢复**

- 冲突时的清晰提示和解决建议
- 危险操作的安全确认（如 force push）
- 操作失败时的数据完整性保证

**4. 配置和个性化**

- 团队级别的配置管理
- 个人偏好的保存和应用
- 项目级别和全局级别的配置支持

**5. 新用户友好**

- 快速上手体验（5 分钟内完成第一个任务）
- 零文档依赖（90% 操作无需查阅文档）
- 统一的交互模式降低学习成本

**6. 复杂场景支持**

- Rebase 工作流的智能处理
- 冲突检测和解决建议
- 历史重写的安全处理

**7. 团队协作能力**

- 团队标准工作流的建立
- 配置的共享和管理
- 协作效率的提升

---

## CLI 工具特定需求

### Project-Type Overview

nemo-cli 是一个交互式 CLI 工具集，采用 Monorepo 架构，提供多个独立但统一的命令（ng, na, np, nf）。工具的核心设计理念是"意图优先"和"智能推断"，通过交互式引导和自动编排，让开发者无需记忆命令语法即可完成日常开发操作。

### 命令结构 (Command Structure)

**交互式设计：**

- 所有命令采用交互式设计，通过对话式提示引导用户完成操作
- 命令执行过程中，工具自动检测上下文并推断用户意图
- 用户只需表达"想做什么"，工具自动处理执行细节

**命令命名规范：**

- 所有命令遵循统一的命名模式：`{prefix} {action} [options]`
- 命令前缀：`ng` (git)、`na` (ai)、`np` (package)、`nf` (file)
- 动作名称：简洁直观，符合直觉（如 `commit`、`checkout`、`pull`）

**命令层次结构：**

- 支持子命令和选项的层次结构
- 所有命令支持 `--help` 获取上下文相关的操作提醒
- 命令参数通过交互式提示获取，无需记忆参数格式

### 输出格式 (Output Formats)

**多格式支持：**

- **默认格式**：适合终端显示的格式化文本输出
- **JSON 格式**：通过 `--json` 选项输出结构化数据，便于脚本处理
- **表格格式**：列表类数据（如分支列表、stash 列表）以表格形式展示
- **静默模式**：通过 `--quiet` 选项减少输出，适合脚本化场景

**输出一致性：**

- 所有命令的输出遵循统一的格式规范
- 错误信息格式统一，包含清晰的错误描述和恢复建议
- 成功/失败状态通过颜色和图标清晰标识

### 配置架构 (Config Schema)

**多层级配置：**

- **全局配置**：存储在 `~/.nemo-cli/config.json`，适用于所有项目
- **项目级别配置**：存储在项目根目录的 `.nemo-clirc` 或 `.nemo-cli/config.json`
- **配置优先级**：项目级别配置 > 全局配置 > 默认值

**配置内容：**

- Pull 策略（merge/rebase）
- 自动 stash 功能开关
- Stash 消息格式模板
- 默认输出格式
- 命令别名

**配置管理：**

- 支持通过命令行查看和修改配置：`ng config get/set`
- 配置文件采用 JSON 格式，易于编辑和版本控制
- 配置变更立即生效，无需重启

### Shell 补全 (Shell Completion)

**支持的 Shell：**

- **Bash**：通过 `ng completion bash` 生成补全脚本
- **Zsh**：通过 `ng completion zsh` 生成补全脚本
- 补全脚本支持命令、子命令、选项和参数的自动补全

**补全功能：**

- 命令补全：输入 `ng` 后按 Tab 显示可用命令
- 选项补全：输入 `ng commit --` 后按 Tab 显示可用选项
- 上下文感知补全：根据当前 Git 状态补全分支名、文件名等

**安装方式：**

- 提供安装脚本：`ng completion install [bash|zsh]`
- 支持手动安装：将补全脚本添加到 shell 配置文件

### 技术架构考虑

**CLI 框架：**

- 使用 Commander.js 作为命令注册和分发框架
- 使用 @clack/prompts 提供交互式提示
- 使用 React Ink 构建终端 UI 组件

**性能要求：**

- 命令启动时间：冷启动 < 200ms，热启动 < 100ms
- 交互响应时间：用户输入后 < 100ms 显示提示
- 输出渲染：表格和列表渲染时间 < 50ms

**可扩展性：**

- 新命令添加时间 < 2 天（基于现有架构）
- 命令遵循统一的交互模式，降低开发成本
- 共享核心库（@nemo-cli/shared）提供统一的基础能力

### 实现考虑

**交互式体验：**

- 所有交互式提示支持键盘导航（方向键、Tab、Enter）
- 支持取消操作（Ctrl+C）并安全退出
- 提供清晰的进度指示和状态反馈

**错误处理：**

- 所有错误都有清晰的错误信息和恢复建议
- 关键操作失败时保留用户数据完整性
- 提供操作日志，便于问题排查

**向后兼容：**

- 现有命令 100% 向后兼容
- 配置格式变更时提供迁移工具
- 新版本发布时保持 API 稳定性

---

## Functional Requirements

### 分支级别 Stash 管理

- **FR1**: 用户切换分支时，系统自动检测未提交更改并执行 stash
- **FR2**: 系统在 stash 消息中记录来源分支名称，格式如 `[ng-auto] branch:feature/xxx timestamp:2025-12-21T10:00:00`
- **FR3**: 用户切换回某分支时，系统自动识别该分支的 stash 并 pop
- **FR4**: 用户可以查看所有分支级别的 stash 列表（按分支分组显示）
- **FR5**: 用户可以手动删除特定分支的 stash
- **FR6**: 系统在自动 pop 时如遇冲突，提示用户手动解决并保留 stash

### Pull 安全模式

- **FR7**: 用户执行 pull 时，系统自动检测工作区是否有未提交更改
- **FR8**: 如有未提交更改，系统自动执行 stash → pull → pop 序列
- **FR9**: 用户可以选择 pull 策略：merge（默认）、rebase
- **FR10**: Rebase 模式下，系统提示用户选择 rebase 目标分支（默认远程同名分支）
- **FR11**: Pull 完成后，系统自动尝试 pop stash
- **FR12**: 如 pop 时有冲突，系统显示冲突文件列表并提示解决方式

### Push 安全模式

- **FR13**: 用户执行 push 时，系统先检查远程是否有新提交
- **FR14**: 如远程有新提交，系统自动执行 pull（使用用户配置的策略）
- **FR15**: Pull 成功且无冲突后，系统自动执行 push
- **FR16**: 如 pull 有冲突，系统提示用户解决冲突后重新 push
- **FR17**: 用户可以使用 force push 选项跳过 pull 检查（用于 rebase 后场景）
- **FR18**: Force push 前系统显示警告并要求确认

### Rebase 工作流优化

- **FR19**: Rebase 完成后，系统检测本地分支与远程分支的差异
- **FR20**: 如检测到历史重写（rebase 导致），系统提示用户需要 force push
- **FR21**: 系统提供选项：force push / 查看差异 / 取消操作
- **FR22**: 用户选择 force push 时，系统执行 `git push --force-with-lease`

### 配置与个性化

- **FR23**: 用户可以配置默认的 pull 策略（merge/rebase）
- **FR24**: 用户可以配置是否启用自动 stash 功能
- **FR25**: 用户可以配置 stash 消息的格式模板
- **FR26**: 配置存储在项目级别或全局级别（用户选择）

### 错误处理与恢复

- **FR27**: 系统在任何自动操作失败时保留用户数据完整性
- **FR28**: 系统提供操作日志，记录自动执行的 Git 命令
- **FR29**: 用户可以查看最近的自动操作历史
- **FR30**: 系统在关键操作前创建恢复点（可选功能）

### 帮助与引导系统

- **FR31**: 所有命令支持 `--help` 选项，提供上下文相关的操作提醒
- **FR32**: 帮助信息清晰、简洁，覆盖 95% 的使用场景
- **FR33**: 系统根据当前上下文提供相关命令建议
- **FR34**: 用户可以通过帮助系统了解命令用法，无需查阅外部文档

### 输出格式与展示

- **FR35**: 系统支持多种输出格式：默认文本格式、JSON 格式（通过 `--json`）、表格格式、静默模式（通过 `--quiet`）
- **FR36**: 所有命令的输出遵循统一的格式规范
- **FR37**: 错误信息格式统一，包含清晰的错误描述和恢复建议
- **FR38**: 成功/失败状态通过颜色和图标清晰标识

### Shell 集成

- **FR39**: 系统支持 Bash 和 Zsh 的自动补全功能
- **FR40**: 用户可以通过命令生成并安装补全脚本
- **FR41**: 补全功能支持命令、子命令、选项和参数的自动补全
- **FR42**: 补全功能根据当前 Git 状态提供上下文感知的补全（如分支名、文件名）

### 配置管理

- **FR43**: 用户可以在全局级别和项目级别配置工具行为
- **FR44**: 用户可以通过命令行查看和修改配置
- **FR45**: 配置变更立即生效，无需重启
- **FR46**: 系统支持配置优先级：项目级别 > 全局级别 > 默认值

### 交互式体验

- **FR47**: 所有命令采用交互式设计，通过对话式提示引导用户完成操作
- **FR48**: 系统自动检测上下文并推断用户意图，减少交互步骤
- **FR49**: 用户可以通过键盘导航（方向键、Tab、Enter）完成交互
- **FR50**: 用户可以在任何时候取消操作（Ctrl+C）并安全退出

---

## Non-Functional Requirements

### Performance（性能要求）

**命令响应时间：**

- **NFR1**: Git 操作性能：分支切换 < 500ms（包含 stash 操作）
- **NFR2**: AI 操作性能：命令响应 < 2s（包含网络延迟）
- **NFR3**: Package 操作性能：依赖分析 < 1s
- **NFR4**: 通用性能：冷启动 < 200ms，热启动 < 100ms
- **NFR5**: Stash 检索和匹配操作在 100ms 内完成

### Reliability（可靠性要求）

**操作成功率与数据完整性：**

- **NFR6**: 操作成功率：> 99%（排除用户输入错误）
- **NFR7**: 错误恢复率：自动恢复 > 90%
- **NFR8**: 数据完整性：零数据丢失（100%）
- **NFR9**: 自动 stash 操作必须原子性执行，失败时回滚到操作前状态
- **NFR10**: 任何情况下不得丢失用户的未提交更改
- **NFR11**: 网络操作（pull/push）超时时提供清晰的错误信息和恢复建议

### Compatibility（兼容性要求）

**平台与工具兼容：**

- **NFR12**: 支持 Git 2.20+ 版本
- **NFR13**: 支持 Node.js ^20.19.0 || >=22.12.0
- **NFR14**: 兼容 macOS、Linux、Windows（通过 WSL）
- **NFR15**: 与现有 ng 命令完全向后兼容（100% 兼容）

### Maintainability（可维护性要求）

**代码质量与可扩展性：**

- **NFR16**: 代码质量：遵循 TypeScript 最佳实践，通过所有 lint 检查
- **NFR17**: 代码覆盖率：单元测试覆盖率 > 80%
- **NFR18**: 代码复杂度：新功能代码的圈复杂度 < 10
- **NFR19**: 文档覆盖率：API 文档覆盖率 100%
- **NFR20**: 可扩展性：新功能添加时间 < 2 天（基于现有架构）
- **NFR21**: 新命令与现有命令风格一致（Commander.js + @clack/prompts）

### Observability（可观测性要求）

**日志与错误追踪：**

- **NFR22**: 操作日志覆盖率：100%（所有操作都有日志记录）
- **NFR23**: 错误追踪：所有错误可追溯，便于问题排查
- **NFR24**: 用户可以查看最近的自动操作历史

---

## PRD 摘要

| 项目 | 内容 |
|------|------|
| **功能需求数量** | 50 个 |
| **非功能需求数量** | 24 个 |
| **MVP 范围** | Git 模块智能化深化、统一帮助系统、基础错误处理 |
| **核心价值** | 让命令行操作像思考一样自然 |

---

_This PRD captures the essence of nemo-cli - 一个智能化的 Git CLI 工具，通过自动化 stash/pull/push 编排，让开发者专注于代码而非 Git 命令。_

_Created through collaborative discovery between BMad and AI facilitator._
